# Text messaging interop sample with console app on Windows side

This folder contains the source files for the interop text messaging sample using a console application on Windows side.


----------------------

## High Level Overview  
The following diagram shows a high-level overview of the interop solution where a native Windows application communicates with an Azure IoT edge Linux module, here a sensor module. We use the Azure SDK and Azure IoT Edge runtime for message routing:<li-image width="515" height="244" alt="twarwick_5-1597346871729.png" align="center" id="212283i26DFAF9A2A7F3877" size="large" resized="true" sourcetype="new"></li-image>
### Windows Application  
The Windows application uses the Azure Device Client Namespace from the Azure SDK. The underlying communication is implemented via the AMQP protocol, i.e., a networking protocol that uses TCP. That means that the Windows application represents an _IoT downstream device_, sometimes referred to as _leaf device_. A downstream device would typically be a device attached to the IoT Edge Device, for instance a peripheral like a sensor.
<table style="background-color: beige; width: 100%;" border="1" width="100%"><tbody><tr><td style="border-style: dotted;" width="100%">_<font size="2">**Note:** The interop design using the Azure SDK based on the AMQP protocol is meant for a rather low bandwidth communication of a limited amount of data and control. In case an application needs a high bandwidth interop channel (such as a high-quality video stream), an additional channel can always be added, for instance, through (localhost) network sockets.</font>_</td></tr></tbody></table>

### Azure IoT Edge for Linux Module  
The module processes messages sent by the downstream devices and can send processed results back to the downstream devices, or to the cloud, as needed. The communication between a downstream device and module is [authenticated using a PKI](https://docs.microsoft.com/en-us/azure/iot-edge/how-to-connect-downstream-device). The downstream device, i.e., Windows application uses a root CA certificate, allowing to authenticate the Azure IoT Edge for Linux instance. The Azure IoT Edge for Linux instance must be configured to use a certificate and according private key that resides within that PKI to establish a secure communication channel. The downstream device first authenticates once with the IoT Hub (using its downstream device connection string). Then, the IoT Hub authenticates the downstream device with the IoT Edge Device, see the [following documentation](https://docs.microsoft.com/en-us/azure/iot-edge/how-to-authenticate-downstream-device). The connection between the downstream device and the IoT Hub is required only once and then works also [when the IoT Edge Device is offline](https://docs.microsoft.com/en-us/azure/iot-edge/offline-capabilities).

### Azure Cloud Entities
The following are the Azure cloud entities involved for the interop communication.*   **Azure IoT Hub:** A managed service to enable bi-directional communication between IoT devices and Azure. It controls the Azure IoT edge device that runs Azure IoT Edge instance, see [here](https://azure.microsoft.com/en-us/services/iot-hub/).*   **Azure IoT edge device:** The Azure IoT edge device entity in the Azure cloud, associated with the Azure IoT edge instance running on the physical IoT device.*   **Downstream (leaf) device:** The Azure IoT downstream device entity in the Azure cloud, associated with the native Windows application.*   **Azure container registry:** A registry of Docker and Open Container Initiative (OCI) images, with support for all OCI artifacts. After developing a Linux module that interacts with a Windows application, the Linux module will be pushed to the registry so that the IoT edge device can download the module from this registry, see more [here](https://azure.microsoft.com/en-us/services/container-registry/).

## Interop Communication Channel
The following description dives deeper and provides a more detailed description on how we use the existing Azure IoT edge architecture for implementing the interoperability between the native Windows application and Azure IoT edge modules running in the Linux VM. An Azure IoT Edge deployment includes a ‘routing engine’ and a ‘routing table’ that defines the message flow among the modules.  The routing table defines a set of routing entries, where each entry defines a message routing between two endpoints. Each endpoint can be an input or an output of a module. Each module then defines handlers for messages routed to its input endpoint. After processing the message, the module can send a response to one of its output endpoints.  The routing engine uses the _module ID_ to identify the source/destination of a message. However, a downstream device does not have a module ID. Thus, for a module to intercept a message coming from a device, a “special” routing table entry is defined, one that applies to messages with no module ID. This way a ‘_device input endpoint_’ is created. The processing module can then setup a handler for messages coming from the device input endpoint.  The above model defines how messages coming from a device are routed to a processing module, but it does not provide a similar way to send back ‘results’ from the module to the device. For that purpose, the module can invoke a method directly on the device, providing the results, see [here](https://docs.microsoft.com/en-us/azure/iot-edge/module-composition#declare-routes).  To realize this communication model for the development of both the Windows application and Linux module, we use the below APIs from the [Azure Devices Client Namespace](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client?view=azure-dotnet) provided by the Azure SDK:  On the downstream device, i.e., Windows application side, use the [DeviceClient Class](https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fdotnet%2Fapi%2Fmicrosoft.azure.devices.client.deviceclient%3Fview%3Dazure-dotnet&data=02%7C01%7Caskariv%40microsoft.com%7C34a145bcfe6548eff89f08d7cd227e3f%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637203420336768911&sdata=V80xBbA4I1cnMoRyz05l7J64fs%2FNLUXcllTXyImJnZc%3D&reserved=0):  *   Device to module messaging: [DeviceClient.SendEventAsync Method](https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fdotnet%2Fapi%2Fmicrosoft.azure.devices.client.deviceclient.sendeventasync%3Fview%3Dazure-dotnet&data=02%7C01%7Caskariv%40microsoft.com%7C34a145bcfe6548eff89f08d7cd227e3f%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637203420336768911&sdata=%2FWUQmOqZgdJAj8MxpfnXKxghh4%2BtdfN5PhxIhmtFObs%3D&reserved=0)*   Message handler registration (from module): [DeviceClient.SetMethodHandlerAsync Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.deviceclient.setmethodhandlerasync?view=azure-dotnet)    *   Message handler callback: [MethodCallback Delegate](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.methodcallback?view=azure-dotnet)On the module side, use the [ModuleClient Class](https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fdotnet%2Fapi%2Fmicrosoft.azure.devices.client.moduleclient%3Fview%3Dazure-dotnet&data=02%7C01%7Caskariv%40microsoft.com%7C34a145bcfe6548eff89f08d7cd227e3f%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637203420336778900&sdata=If5Qf7TKLh8mbO0MacjM6tiD61Hmo9AEUoRtUb2bGpI%3D&reserved=0)<span>:</span>*   Module to device messaging: [ModuleClient.InvokeMethodAsync Method](https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fdotnet%2Fapi%2Fmicrosoft.azure.devices.client.moduleclient.invokemethodasync%3Fview%3Dazure-dotnet&data=02%7C01%7Caskariv%40microsoft.com%7C34a145bcfe6548eff89f08d7cd227e3f%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637203420336778900&sdata=VhhVrSTE7IcAFyot39BFZl8g5rh62u%2FkFtL8NW3Hp%2FI%3D&reserved=0)*   Message handler registration (from device): [ModuleClient.SetInputMessageHandler](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.moduleclient.setinputmessagehandlerasync?view=azure-dotnet#Microsoft_Azure_Devices_Client_ModuleClient_SetInputMessageHandlerAsync_System_String_Microsoft_Azure_Devices_Client_MessageHandler_System_Object_)<span>Async Method</span>    *   Module handler callback: [MessageHandler](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.messagehandler?view=azure-dotnet) <span>delegate</span>Find more about the detailed usage of these functions along with code snippets in the appendix [Detailed usage of Azure SDK APIs](#_Detailed_usage_of).

## Building an Interop Sample  
This sample provides step by step instructions for a sample that demonstrates the basic usage of the interop concepts discussed above. In the sample, a Windows console application sends messages to a custom IoT edge module that sends back a reply message. The following steps are required to build the interop solution and explained in detail below.<table style="background-color: beige; width: 100%;" border="1" width="100%"><tbody><tr><td style="border-style: dotted;" width="100%">_<font size="2">**Note:** Appendix [Extending the Interop Solution](#_Extending_the_Interop) describes how this simple interop solution can be extended to work with unmodified Azure marketplace modules instead of with self-written modules.</font>_</td></tr></tbody></table>

### Pre-requisites*   
Reader has an Azure subscription and is familiar with the basics of the Azure Portal.*   Setup of Azure IoT Edge for Linux on Windows using one of the two options below*   WSL 2, (see [Internet of Things Blog](https://aka.ms/winiot-low))*   Deploy a Linux VM (e.g. Ubuntu) on Windows and [Install the Azure IoT Edge runtime on Debian-based Linux system](https://docs.microsoft.com/en-us/azure/iot-edge/how-to-install-iot-edge-linux)*   Access to a Windows device with PowerShell installed where you can run scripts to set up an Azure Virtual Machine as your development machine.

### Step 1: Set up a development VM   
In this step, we set up a development VM for building and publishing the Linux modules and for building the Windows console application. Th development VM is an Azure cloud VM but can theoretically be also set up as a development environment on a Windows development device.1.  Follow the steps 'Set up the development VM', 'Connect to the development VM', 'Install Visual Studio Code extensions' from [this tutorial](https://docs.microsoft.com/en-us/azure/iot-edge/tutorial-machine-learning-edge-02-prepare-environment).2.  Log into the Azure cloud VM as described in the tutorial<table style="background-color: beige; width: 100%;" border="1" width="100%"><tbody><tr><td style="border-style: dotted;" width="100%">_<font size="2">**Note:** If you cannot connect to the VM via RDP, ensure RDP port 3389 is not blocked for the VM. Navigate to the Azure portal and investigate the incoming networking rules. Allowing RDP through 53389 can provide immediate mitigation. There are three steps to change the RDP port. To follow these steps, open the Azure portal and navigate to your virtual machine.</font>_1.  _<font size="2">Go to 'Run command'. Run the command 'SetRDPPort 53389'.</font>_2.  _<font size="2">Go to 'Networking' and add an inbound port rule, allowing port 53389.</font>_3.  _<font size="2">Go to 'Connect' select 'RDP' and change the port number to 53389\. Download the generated RDP file.</font>_</td></tr></tbody></table>  

### Step 2: Set up Azure resources  
Our showcase uses a configuration in the Azure IoT Portal with a sample _IoT Hub_, _IoT Edge Device_, and _IoT Downstream Device._*   The ** _IoT Hub_ ** is the cloud-based hub instance that controls our edge device that runs Azure IoT Edge instance.*   The **_IoT Edge Device_ **represents the virtual device that runs the Azure IoT Edge for Linux instance.*   The_**IoT Downstream Device**_represents our Windows application that communicates with the Linux module. This is inherited by using the Azure Device Client Namespace for the communication between Windows application and Linux module, which lets the Windows application act as a downstream device.This part describes how to set up the required Azure entities with the [Azure Cloud Shell](https://docs.microsoft.com/en-us/azure/cloud-shell/features). Alternatively you can use Azure PowerShell module, the installation instructions are documented [here](https://docs.microsoft.com/en-us/powershell/azure/install-az-ps). This should be executed on any Windows host other than the (emulated) target device. We propose using the VM that serves as development environment.

#### 2.1  
[Azure PowerShell module only] Load the Az PowerShell module:
<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">powershell -ExecutionPolicy Bypass</li-code></td><td style="border-style: dotted;">required if PowerShell execution policy disallows module loading</td></tr><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">Import-Module Az</li-code></td><td style="border-style: dotted;">required if module is not imported by default</td></tr></tbody></table>

#### 2.2  
Sign into the Azure Portal with this session only. Follow sign in instructions. See [here](https://docs.microsoft.com/en-us/powershell/azure/context-persistence) how to persist sign ins across PowerShell sessions:<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">Connect-AzAccount</li-code></td></tr></tbody></table>

#### 2.3  
Use the <font color="#FF6600"><span>Set-AzContext -SubscriptionId "<UUID>"</span></font> command to set the subscription ID context. To determine the UUID, use the <font color="#FF6600"><span>Get-AzSubscription</span></font> command to retrieve a list of subscriptions along with their UUID you are enrolled to.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"></td></tr></tbody></table>
  
#### 2.4  
[optional] Create a resource group, see also [here](https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-create-using-powershell). You might decide to skip this step and be able to use an existing resource group. Ensure to select a suitable subscription under which to create a resource group (make sure you have a subscription that allows you creating resource groups).Use the <font color="#FF6600"><span>New-AzResourceGroup -Name InteropSampleRG -Location "West US"</span></font> command to create the resource group, see also [here](https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-create-using-powershell). <font color="#FF6600">Use <span>Get-AzResourceGroup</span></font> to verify that the resource group has been created under your subscription.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"></td></tr></tbody></table>

#### 2.5  
[optional] If not available, create an IoT Hub in a specific resource group, see also [here](https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-create-using-powershell)<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">New-AzIotHub -ResourceGroupName InteropSampleRG -Name InteropSampleIoTHub -SkuName S1 -Units 1 -Location "West US"</li-code></td></tr></tbody></table>

#### 2.6  
Create an IoT Edge Device, see also [here](https://docs.microsoft.com/en-us/powershell/module/az.iothub/add-aziothubdevice)<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">Add-AzIoTHubDevice -ResourceGroupName InteropSampleRG -IoTHubName InteropSampleIoTHub -DeviceId InteropSampleEdgeDev -EdgeEnabled</li-code></td></tr></tbody></table>

#### 2.7
Create an IoT Downstream Device with the IoT Edge Device as parent, see also [here](https://docs.microsoft.com/en-us/powershell/module/az.iothub/add-aziothubdevice)<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">Add-AzIoTHubDevice -ResourceGroupName InteropSampleRG -IoTHubName InteropSampleIoTHub -DeviceId InteropSampleLeafDev -ParentDeviceId InteropSampleEdgeDev</li-code></td></tr></tbody></table><li-code lang="powershell">Add-AzIoTHubDevice -ResourceGroupName InteropSampleRG -IoTHubName InteropSampleIoTHub -DeviceId InteropSampleLeafDev -ParentDeviceId InteropSampleEdgeDev</li-code>

#### 2.8
Note down connection strings for IoT Edge and Leaf devices for use in later steps:<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">Get-AzIotHubDCS -ResourceGroupName InteropSampleRG -IotHubName InteropSampleIoTHub -DeviceId InteropSampleEdgeDev -KeyType primary | fl * Get-AzIotHubDCS -ResourceGroupName InteropSampleRG -IotHubName InteropSampleIoTHub -DeviceId InteropSampleLeafDev -KeyType primary | fl *</li-code></td></tr></tbody></table>

#### 2.9
[Optional] Create a registry for the modules part of this sample, see also [here](https://docs.microsoft.com/en-us/powershell/module/az.containerregistry/New-AzContainerRegistry) (or, use an existing registry):<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">New-AzContainerRegistry -ResourceGroupName InteropSampleRG -Name InteropSampleRegistry -Sku "Basic" -EnableAdminUser</li-code></td></tr></tbody></table>

### Step 3: Develop and publish the IoT edge Linux module
In this part we develop and publish the Linux modules in the development VM using Visual Studio Code.

#### 3.1
From the Tutorial: Develop a C# IoT Edge module for Linux devices, perform the following steps. [Prerequisites](https://docs.microsoft.com/en-us/azure/iot-edge/tutorial-csharp-module#prerequisites)[Create a new project](https://docs.microsoft.com/en-us/azure/iot-edge/tutorial-csharp-module#create-a-new-project)**<font color="#FF0000">Important:</font>** Do not complete other steps from this tutorial.

#### 3.2
Having the project setup, open the file Program.cs in the folder “modules/CSharpModule” in the Visual Studio Code explorer.  At the top of the **CSharpModule** namespace in Program.cs, add below **using** statement for types that are used later:<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="chsarp">using Newtonsoft.Json</li-code></td></tr></tbody></table>

#### 3.3
Add below UtcDateTime utility method to the class ‘Program’.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="chsarp">private static string UtcDateTime { get { return DateTime.Now.ToUniversalTime().ToString("G"); } }</li-code></td></tr></tbody></table>

#### 3.4
Add the following method to the class ‘Program’ for sending messages to the leaf device which invokes the method ModuleClient.InvokeMethodAsync.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="chsarp">/// <summary> /// This method will send message to leaf device by invoking leaf device direct method. /// </summary> static async Task SendMessageToLeafDevice(string deviceId, ModuleClient moduleClient ) { try { string message = $"hello from edge!"; string jString = JsonConvert.SerializeObject(message); var methodRequest = new MethodRequest("LeafDeviceDirectMethod", Encoding.UTF8.GetBytes(jString)); var response = await moduleClient.InvokeMethodAsync(deviceId, methodRequest); if(response.Status == 200) { Console.WriteLine($"{UtcDateTime} sent message:{message}"); } else { Console.WriteLine($"Error occurred invoking LeafDeviceDirectMethod. error status code {response.Status}"); } } catch (Exception ex) { Console.WriteLine($"SendMessageToLeafDevice got exception {ex.Message}"); } }</li-code></td></tr></tbody></table>

#### 3.5
Replace the ‘PipeMessage’ method with the below method which will be invoked upon messages received from Windows application.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="chsarp">/// <summary> /// This method is called whenever a leaf device sent a message to edge. /// </summary> static async Task<MessageResponse> LeafDeviceMessageHandlerAsync(Message message, object userContext) { try{ var moduleClient = userContext as ModuleClient; if (moduleClient == null) { throw new InvalidOperationException("UserContext doesn't contain " + "expected values"); } var messageData = message.GetBytes(); string receivedMessage = Encoding.UTF8.GetString(messageData); Console.WriteLine($"Received message: {receivedMessage}"); SendMessageToLeafDevice(message.ConnectionDeviceId, moduleClient); }catch(Exception ex) { Console.WriteLine("Exception occurred {ex.StackTrace}"); } return MessageResponse.Completed; }</li-code></td></tr></tbody></table>

#### 3.6
Find the Init task function in Program.cs. This function creates and configures a ModuleClient object, which allows the module to connect to the local Azure IoT Edge runtime to send and receive messages. After creating the ModuleClient, the code sets message handler to read the messages from downstream device. To make this change, replace the Init function with the below code.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="chsarp">/// Summary /// Initializes the ModuleClient and sets up the callback to receive /// messages containing temperature information /// </summary> static async Task Init() { AmqpTransportSettings amqpSetting = new AmqpTransportSettings(TransportType.Amqp_Tcp_Only); ITransportSettings[] settings = { amqpSetting }; // Open a connection to the Edge runtime ModuleClient ioTHubModuleClient = await ModuleClient.CreateFromEnvironmentAsync(settings); await ioTHubModuleClient.OpenAsync(); Console.WriteLine("ModuleClient initialized"); // Register callback to be called when a message is received by the proxy module from leaf device. await ioTHubModuleClient.SetInputMessageHandlerAsync("leafdeviceinput", LeafDeviceMessageHandlerAsync, ioTHubModuleClient); }</li-code></td></tr></tbody></table>

#### 3.7
Configure the routing table in the project file deployment.template.json to redirect the messages received from the windows application to CSharpModule by removing all the entries in the routes and adding below entry to “routes”.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="json">"leafdeviceinputendpoint": "FROM /messages/* WHERE NOT IS_DEFINED($connectionModuleId) INTO BrokeredEndpoint(\"/modules/CSharpModule/inputs/leafdeviceinput\")"</li-code></td></tr></tbody></table>

#### 3.8
Remove below temperature sensor module from deployment.template.json as it is not needed.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="json">, "SimulatedTemperatureSensor": { "version": "1.0", "type": "docker", "status": "running", "restartPolicy": "always", "settings": { "image": "mcr.microsoft.com/azureiotedge-simulated-temperature-sensor:1.0", "createOptions": {} }</li-code></td></tr></tbody></table>

#### 3.9
Create a .env file in the main project folder with the container registry authentication details as variables:<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="txt">CONTAINER_REGISTRY_USERNAME_<registryname>=XXX CONTAINER_REGISTRY_PASSWORD_<registryname>=XXX</li-code></td></tr></tbody></table>Replace the <registryname> with the name of your container registry and the two 'XXX' in with the username and password for that container registry as found in the Azure Portal (navigate to your container registry in the Azure Portal and go to the tab 'Access Keys').
  
#### 3.10
Add your registry credentials to the deployment.template.json file, setting <registryname> to the name of your container registry:<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="json">"<registryname>": { "username": "$CONTAINER_REGISTRY_USERNAME_<registryname>", "password": "$CONTAINER_REGISTRY_PASSWORD_<registryname>", "address": "<registryname>.azurecr.io" }</li-code></td></tr></tbody></table>
  
#### 3.11
Ensure your registry name is set in the modules/CSharpModule/module.json (see former “Create new project” step):<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="json">… "repository": "<registryname>.azurecr.io" …</li-code></td></tr></tbody></table>

#### 3.12
Follow the steps in “[Build and push your module](https://docs.microsoft.com/en-us/azure/iot-edge/tutorial-csharp-module#build-and-push-your-module)” section from this [tutorial](https://docs.microsoft.com/en-us/azure/iot-edge/tutorial-csharp-module#build-and-push-your-module). Use the container registry credentials of your container registry for the docker login.

### Step 4: Develop the Windows C# Console Application
This part describes how to develop the Windows console application in the development VM.

#### 4.1
In VS Code Explorer, open the EdgeSolution folder created above.Go to the terminal window and change to the folder EdgeSolution.Run below command to create project. It will create a project based on the console template.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">dotnet new console -n LeafDeviceApp</li-code></td></tr></tbody></table>

#### 4.2
Create the file “EdgeSolution\LeafDeviceApp\CertificateManager.cs” and paste the below contents into it.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="csharp">using System; using System.IO; using System.Security.Cryptography.X509Certificates; namespace LeafDeviceApp { internal class CertificateManager { /// <summary> /// Add certificate in local cert store for use by downstream device /// client for secure connection to IoT Edge runtime. /// /// Note: On Windows machines, if you have not run this from an Administrator prompt, /// a prompt will likely come up to confirm the installation of the certificate. /// This usually happens the first time a certificate will be installed. /// </summary> public static void InstallCACert(string certificatePath) { if (string.IsNullOrWhiteSpace(certificatePath)) { throw new ArgumentNullException(nameof(certificatePath)); } Console.WriteLine($"User configured CA certificate path: {certificatePath}"); if (!File.Exists(certificatePath)) { // cannot proceed further without a proper cert file Console.WriteLine($"Invalid certificate file: {certificatePath}"); throw new InvalidOperationException("Invalid certificate file."); } else { Console.WriteLine($"Attempting to install CA certificate: {certificatePath}"); var store = new X509Store(StoreName.Root, StoreLocation.CurrentUser); store.Open(OpenFlags.ReadWrite); store.Add(new X509Certificate2(X509Certificate2.CreateFromCertFile(certificatePath))); Console.WriteLine($"Successfully added certificate: {certificatePath}"); store.Close(); } } } }</li-code></td></tr></tbody></table>

#### 4.3Replace the EdgeSolution\LeafDeviceApp\Program.cs file with the below code which includesSending message to iotedge device using “DeviceClient.SentEventSync”Setting direct method callback using “DeviceClient.SetMethodHandlerAsync”Options to read IoT hub connection string, IoT edge device hostname, edge root certificate file path.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="csharp">using System; using System.Text; using System.Threading.Tasks; using Microsoft.Azure.Devices.Client; using Microsoft.Extensions.CommandLineUtils; using Newtonsoft.Json; namespace LeafDeviceApp { class Program { static void Main(string[] args) { InitializeApp(); app.OnExecute(() => { InstallCertificate(); string iotHubConnectionString = GetConnectionString(); string gatewayHost = GetGatewayHostName(); string deviceConnectionString = $"{iotHubConnectionString};GatewayHostName={gatewayHost}"; deviceClient = DeviceClient.CreateFromConnectionString(deviceConnectionString); deviceClient.SetMethodHandlerAsync("LeafDeviceDirectMethod", LeafDeviceMethodCallback, null).Wait(); ConsoleKeyInfo input; while(true) { Console.WriteLine("Press 1 to send message and any other key for exit."); input = Console.ReadKey(); if(input.Key != ConsoleKey.D1) { break; } SendMessage().Wait(); } return 0; }); app.Execute(args); Console.ReadLine(); } private static CommandLineApplication app = new CommandLineApplication(); private static CommandOption connectionStringOption; private static CommandOption certificateOption; private static CommandOption gatewayHostNameOption; private static DeviceClient deviceClient; /// <summary> /// Initializes the instance of the CommandLineApplication /// </summary> private static void InitializeApp() { app.Name = "LeafDeviceApp"; app.Description = "Leaf device to communicate with edge gateway device."; app.HelpOption("-?|-h|--help"); connectionStringOption = app.Option( "-x|--connection", @"IoT Hub Connection String e.g HostName=hubname.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=xxxxxx;", CommandOptionType.SingleValue); certificateOption = app.Option( "-c|--certificate", "File path to Root CA certificate in PEM format", CommandOptionType.SingleValue); gatewayHostNameOption = app.Option( "-g|--gateway-host-name", "Fully qualified domain name of the edge device acting as a gateway. e.g. iotedge-xxx.westus2.cloudapp.azure.com ", CommandOptionType.SingleValue); } /// <summary> /// Looks for a certificate either passed as a parameter or in the CA_CERTIFICATE_PATH /// environment variable and, if present, attempts to install the certificate /// </summary> private static void InstallCertificate() { string certificatePath; if (!certificateOption.HasValue()) { certificatePath = Environment.GetEnvironmentVariable("CA_CERTIFICATE_PATH"); } else { certificatePath = certificateOption.Value(); } if (!String.IsNullOrWhiteSpace(certificatePath)) { CertificateManager.InstallCACert(certificatePath); } } /// <summary> /// Retrieves the value of the connection string from the connectionStringOption. /// If the connection string wasn't passed method prompts for the connection string. /// </summary> /// <returns></returns> private static string GetConnectionString() { string connectionString; if (!connectionStringOption.HasValue()) { connectionString = Environment.GetEnvironmentVariable("DEVICE_CONNECTION_STRING"); app.ShowHint(); } else { connectionString = connectionStringOption.Value(); } while (String.IsNullOrWhiteSpace(connectionString)) { Console.WriteLine("Please enter IoT Hub Connection String:"); connectionString = Console.ReadLine(); } Console.WriteLine($"Using connection string: {connectionString}"); return connectionString; } /// <summary> /// Get fully qualified domain name of the edge device acting as a gateway. e.g. iotedge-xxx.westus2.cloudapp.azure.com. /// If the gateway host name wasn't passed method prompts for the gateway host name. /// </summary> /// <returns></returns> private static string GetGatewayHostName() { string gatewayHostName; if (!gatewayHostNameOption.HasValue()) { gatewayHostName = Environment.GetEnvironmentVariable("GATEWAY_HOST_NAME"); app.ShowHint(); } else { gatewayHostName = gatewayHostNameOption.Value(); } while (String.IsNullOrWhiteSpace(gatewayHostName)) { Console.WriteLine("Please enter edge gate way host name:"); gatewayHostName = Console.ReadLine(); } Console.WriteLine($"Using gateway host name: {gatewayHostName}"); return gatewayHostName; } private static Task<MethodResponse> LeafDeviceMethodCallback(MethodRequest methodRequest, object userContext ) { if (methodRequest.Data != null) { var data = Encoding.UTF8.GetString(methodRequest.Data); Console.WriteLine($"Edge reply: {data}"); string jString = JsonConvert.SerializeObject("Success"); return Task.FromResult(new MethodResponse(Encoding.UTF8.GetBytes(jString), 200)); } else { Console.WriteLine("Edge reply: Empty"); string jString = JsonConvert.SerializeObject("Empty"); return Task.FromResult(new MethodResponse(Encoding.UTF8.GetBytes(jString), 400)); } } /// <summary> /// This method will send message to edge gateway/iothub. /// </summary> private static async Task SendMessage() { string message = $"Hi Edge, How are you doing!"; Console.WriteLine($"Device says: {message}"); using (var eventMessage = new Message(Encoding.UTF8.GetBytes(message))) { // Set the content type and encoding so the IoT Hub knows to treat the message body as JSON eventMessage.ContentEncoding = "utf-8"; eventMessage.ContentType = "application/json"; await deviceClient.SendEventAsync(eventMessage); } } } }</li-code></td></tr></tbody></table>

#### 4.4
Open the file EdgeSolution\LeafDeviceApp\LeafDeviceApp.csproj and add below entry inside the Project node:<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="txt"><ItemGroup> <PackageReference Include="Microsoft.Azure.Devices.Client" Version="1.18.1" /> <PackageReference Include="Microsoft.Extensions.CommandLineUtils" Version="1.1.1" /> </ItemGroup></li-code></td></tr></tbody></table>

#### 4.5
Go back to the previous terminal, change to the folder EdgeSolution\LeafDeviceApp\ and run below command for building the project.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">dotnet build</li-code></td></tr></tbody></table>

#### 4.6
Run the below command to publish the binary, see more [here](https://docs.microsoft.com/en-us/dotnet/core/deploying/trim-self-contained).<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">dotnet publish -c Release -r win10-x64 --self-contained true -p:PublishSingleFile=true -p:PublishTrimmed=true</li-code></td></tr></tbody></table>

#### 4.7
It will create a single binary along with the symbols in the below location. Copy the following build artifact folder onto the IoT device’s Windows OS:<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">EdgeSolution\LeafDeviceApp\bin\Release\netcoreapp3.1\win10-x64\publish\</li-code></td></tr></tbody></table>

### Step 5: Create Certificates for Authentication
This part describes the relevant steps to create sample certificates for the authentication between downstream device and IoT edge.*   The following [link](https://docs.microsoft.com/en-us/azure/iot-edge/tutorial-machine-learning-edge-05-configure-edge-device#create-certificates) provides a tutorial on how to create a sample PKI with certificate validity for one month. You only need to generate certificates and do not need to upload them to Azure Key Vault. If you want to generate customizable certificates, please follow the appendix [Customizing Sample Certificates](#_Customizing_Sample_Certificates) .*   You can also use your own root CA certificate in case you have a (test) PKI for downstream devices and edge devices. In any of the two latter cases, replace the private key, certificate chain, and root CA cert.

### Step 6: Configuring the IoT Edge Device.
In this part we configure the Azure IoT Edge for Linux instance on the IoT edge device.

#### Steps on the Windows OS on the IoT Edge Device
In the next steps we copy the sample certificates to the Linux environment. Copy the private key, certificate chain, root CA cert for authenticating the IoT Edge Device from the development VM to this Windows IoT device ('new-edge-device.key.pem', 'new-edge-device-full-chain.cert.pem', 'azure-iot-test-only.root.ca.cert.pem') to the '~/certs' folder.*   WSL2: Copy the files, for instance, via accessing the Linux filesystem through the patch '\wsl$' in File Explorer*   Linux VM: Use SSH to create a folder in the Linux environment and scp to copy the private key, certificate chain, and root CA cert:<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">ssh <username>@<VM IP/hostname> mkdir -p ~/certs scp .\certs\* <username>@<VM IP Address>:~/certs/</li-code></td></tr></tbody></table>
  
#### Steps in the Linux environment of the IoT Edge Device*   Log in to the Linux environment*   WSL2: Follow the [blog post](https://aka.ms/winiot-low) to change into the WSL environment*   Linux VM: Use SSH to log in to the Linux environment<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">ssh <username>@<VM IP address></li-code></td></tr></tbody></table>*   Set up the Linux firewall for the interop of Windows application and Linux module. As the Azure Device Client Namespace is used, we use the underlying AMQP protocol for the exchange of messages. We need to specifically allow incoming packets on the ports required by the AMQP protocol. We thus adapt the firewall rules as follows and persist them across reboots:<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="bash">sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT sudo iptables -A INPUT -p tcp --dport 5671 -j ACCEPT sudo iptables-save | sudo tee /etc/systemd/scripts/ip4save > /dev/null</li-code></td></tr></tbody></table>*   Run <font color="#FF6600">sudo chown -R iotedge: ~/certs</font> to allow Azure IoT Edge to read the certificates.*   Provision the Azure IoT Edge for Linux configuration:    *   Run <font color="#FF6600"><span>sudo nano /etc/iotedge/config.yaml</span></font> to start editing the config file.    *   To set the connection string for the IoT Edge Device (queried previously, see _Steps in the Azure IoT Portal_), set the device connection string in the configuration file:<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="yaml"># Manual provisioning configuration provisioning: source: "manual" device_connection_string: "<IoT Edge Device connection string>"</li-code></td></tr></tbody></table>*   Enable the following lines to enable using the private key, certificate chain and root CA certificate required for the authenticated communication with the downstream device. This 'configures the edge device to act as a gateway'. The keys were previously deployed onto the VM, see _Steps in the Windows IoT device_.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="yaml">certificates: device_ca_cert: "/home/efl-user/certs/new-edge-device-full-chain.cert.pem" device_ca_pk: "/home/efl-user/certs/new-edge-device.key.pem" trusted_ca_certs: "/home/efl-user/certs/azure-iot-test-only.root.ca.cert.pem"</li-code></td></tr></tbody></table>*   If you are on a network with dynamic DNS, then edge modules will automatically be able to resolve the VM’s IP address from its hostname. If you are on a network without dynamic DNS, you will need to assign the VM a static IP address and change the line 'hostname: "…"' to 'hostname: "<VM IP Address>"'.*   To save the file and exit nano, press CTRL+x, confirm save and exit with ‘Y’ and press 'Enter'. This concludes the provisioning and configuration.*   Restart the iotedge by running the below command.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="bash">sudo systemctl restart iotedg</li-code></td></tr></tbody></table>*   Check the iotedge configured correctly by running the below command.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="bash">sudo iotedge check</li-code></td></tr></tbody></table>The command checks if IoT Edge is configured correctly. If you find any errors, please refer the [tutorial](https://docs.microsoft.com/en-us/azure/iot-edge/troubleshoot) to troubleshoot.
  
### Step 7: Deploy the Modules onto the IoT Edge Device.
Having the IoT Edge device set up, we now deploy the Linux modules onto the device.
#### Steps in the development VM
Create an IoT Deployment containing the Linux modules and add it to our sample IoT Edge Device:*   This means to deploy the deployment manifest onto your IoT Edge device*   Using VS code, follow the steps “Sign in to access your IoT hub”, “Deploy to your device” as documented [here](https://docs.microsoft.com/en-us/azure/iot-edge/how-to-deploy-modules-vscode). Select the file 'deployment.amd64.json' in the folder ‘config’ as manifest file to be deployed.

#### Steps in the Linux environment of the IoT Edge Device
*   Change into the Linux environment, see description above*   Run the following command which should list the CSharpModule as depicted in the screenshot shown below<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="bash">sudo iotedge list</li-code></td></tr></tbody></table><font size="6" color="#FF00FF">Need to Update this Screen Shot as it is using a Mariner VM.</font><li-image width="714" height="132" alt="twarwick_1-1597346647817.png" align="inline" id="212280iC67CA62447A97C68" size="large" resized="true" sourcetype="new"></li-image>

### Step 8: Run the Console Application
We now deploy the Windows application onto the IoT device and run it to let it interoperate with the Linux modules.

#### Steps on the Windows OS on the IoT Edge Device
1.  Change into the console application package folder previously copied to the Windows IoT device.2.  Run the console application on the command prompt by running the below command.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="powershell">.\LeafDeviceApp.exe -x "<leaf device connection string>" -g "<Linux VM IP address>" -c "<full path to root CA certificate>"</li-code></td></tr></tbody></table>            Press 1 to send a message to the Linux module.*   Please find the screenshot of the running the console application:<li-image width="723" height="224" alt="twarwick_2-1597346647827.png" align="inline" id="212279i7C72380D748A3643" size="large" resized="true" sourcetype="new"></li-image>
  
 #### Steps in the Linux environment of the IoT Edge Device
Run the below command to see the edge logs<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="bash">sudo iotedge logs CSharpModule</li-code></td></tr></tbody></table>

## Appendix

### Extending the Interop Solution
<span>The above sample demonstrates</span> the implementation of <span>minimal interop</span> <span>functionality,</span> <span>but it is not sufficient for directly</span> interoperating with <span>Azure</span> <span>marketplace</span> <span>modules (</span>referred to as ‘<span>Processing</span> m<span>odule</span>’ <span>in below diagram). In general</span>, <span>modifying Azure market</span>place <span>modules to adjust for interop communication is complex or not possible. To resolve the problem,</span> we are <span>introducing</span> a <span>custom proxy module which</span> enables <span>interop communication with</span> the <span>Processing module.</span> <span>This</span> <span>module</span> <span>performs the following</span> (an implementation can be found in the custom vision sample [here](https://aka.ms/winiotsamples))<span>:</span>1.  <span>Intercept the messages coming from the device ‘Device Input EP’.</span>2.  <span>In its ‘Device Input’ endpoint handler the proxy module sends the message to its ‘Processing Output EP’ which is routed (deployment routine table) to the processing module ‘Data Input EP’.</span>3.  <span>In its ‘Data Input’ handler the processing module processes the data and sends the results to its output endpoint ‘Result Output EP’, which is routed to the proxy module ‘Result Input EP’.</span>4.  <span>Finally, in the proxy module’s ‘Result Input’ endpoint handler, the proxy module invokes the ‘result’ method on the</span> downstream <span>device (</span>Windows <span>app</span>lication<span>).</span><span>The following diagram shows the detailed dataflow describes the example of a single Windows</span> application <span>communicating with a single Linux module through our custom proxy module:</span><li-image width="676" height="380" alt="twarwick_4-1597346647841.png" align="inline" id="212282iBC85B0382E5BCDD6" size="large" resized="true" sourcetype="new"></li-image>

### Detailed Usage of the Azure SDK API
<span>This appendix describes the detailed usage of the Azure SDK API for the interop communication.</span><span>On the Windows application, i.e., downstream device</span>1.  Initialize DeviceClient object: This object initializes the connection with the IoT Hub/edgeHub to communicate with the IoT edge device by using [DeviceClient.CreateFromConnectionString](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.deviceclient.createfromconnectionstring?view=azure-dotnet)() method.<table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="csharp">var deviceClient = DeviceClient.CreateFromConnectionString(deviceConnectionString);</li-code></td></tr></tbody></table>For sending messages to the module, first create the Message object with the data you like to send and then invoke the [DeviceClient.SendEventAsync](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.deviceclient.sendeventasync?view=azure-dotnet) method to pass the Message.*   <sample code snippet><table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="csharp">string message = $"Hi Edge, How are you doing!"; using (var eventMessage = new Message(Encoding.UTF8.GetBytes(message))) { // Set the content type and encoding so the IoT Hub knows to treat the message body as JSON eventMessage.ContentEncoding = "utf-8"; eventMessage.ContentType = "application/json"; await deviceClient.SendEventAsync(eventMessage); }</li-code></td></tr></tbody></table>1.  Receive messages sent by module: Initially define a method with a [MethodCallback Delegate](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.methodcallback?view=azure-dotnet) signature to process the messages and then register the method as callback using the [DeviceClient.SetMethodHandlerAsync Method](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.deviceclient.setmethodhandlerasync?view=azure-dotnet)*   <sample code snippet><table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="csharp">// Register the method as callback when receiving the message. deviceClient.SetMethodHandlerAsync("LeafDeviceDirectMethod", LeafDeviceMethodCallback, null).Wait(); // Call back method private static Task<MethodResponse> LeafDeviceMethodCallback(MethodRequest methodRequest, object userContext ) { var data = Encoding.UTF8.GetString(methodRequest.Data); Console.WriteLine($"received message: {data}"); string jString = JsonConvert.SerializeObject("Success"); return Task.FromResult(new MethodResponse(Encoding.UTF8.GetBytes(jString), 200)); }</li-code></td></tr></tbody></table><span>On the module side:</span>1.  Receive the messages sent by the Windows application: Initially define a method with a [MessageHandler](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.messagehandler?view=azure-dotnet) signature to process the messages and then register the method as callback using the [ModuleClient.SetInputMessageHandler](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.moduleclient.setinputmessagehandlerasync?view=azure-dotnet#Microsoft_Azure_Devices_Client_ModuleClient_SetInputMessageHandlerAsync_System_String_Microsoft_Azure_Devices_Client_MessageHandler_System_Object_) method.*   <sample code snippet><table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="csharp">// Register callback to be called when a message is received by the module from windows application. await ioTHubModuleClient.SetInputMessageHandlerAsync("leafdeviceinput", LeafDeviceMessageHandlerAsync, ioTHubModuleClient); // This method is called whenever a leaf device sent a message to edge. static async Task<MessageResponse> LeafDeviceMessageHandlerAsync (Message message, object userContext) { var moduleClient = userContext as ModuleClient; string deviceId = message.Properties["deviceId"]; string receivedMessage = Encoding.UTF8.GetString(message.GetBytes()); Console.WriteLine($"Received message: {receivedMessage}"); return MessageResponse.Completed; }</li-code></td></tr></tbody></table>Note that leafdeviceinput is an end point defined in routing table i.e. deployment.template.json file to route messages to this Linux module.1.  Sending messages to windows application: Initially create the [MethodRequest](https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.devices.client.methodrequest?view=azure-dotnet) object and then invoke the [ModuleClient.InvokeMethodAsync Method](https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fdotnet%2Fapi%2Fmicrosoft.azure.devices.client.moduleclient.invokemethodasync%3Fview%3Dazure-dotnet&data=02%7C01%7Caskariv%40microsoft.com%7C34a145bcfe6548eff89f08d7cd227e3f%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637203420336778900&sdata=VhhVrSTE7IcAFyot39BFZl8g5rh62u%2FkFtL8NW3Hp%2FI%3D&reserved=0) to send message to the application.*   <sample code snippet><table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="csharp">string message = ($”{UtcDateTime} hello from edge!”; string jString = JsonConvert.SerializeObject(message); var methodRequest = new MethodRequest("LeafDeviceDirectMethod", Encoding.UTF8.GetBytes(jString)); var response = await moduleClient.InvokeMethodAsync(deviceId, methodRequest); if(response.Status == 200){ Console.WriteLine(”message sent successfully.”);} else{ Console.WriteLine($"Error occurred invoking LeafDeviceDirectMethod. error status code {response.Status}"); }</li-code></td></tr></tbody></table>1.  Customize the routing table: For a module to intercept a message coming from a device, a “special” routing table entry is defined, one that applies to messages with no module ID. This way a ‘_device input endpoint_’ is created. The processing module can then setup a handler for messages coming from the device input endpoint.*   <sample routing table snippet to add in deployment.template.json><table style="border-style: dotted;" border="1" width="100%"><tbody><tr style="border-style: dotted;"><td style="border-style: dotted;" width="10 px"> </td><td style="border-style: dotted;"><li-code lang="jon">"routes": { "leafdeviceinputendpoint": "FROM /messages/* WHERE NOT IS_DEFINED($connectionModuleId) INTO BrokeredEndpoint(\"/modules/csharpmodule/inputs/leafdeviceinput\")"}</li-code></td></tr></tbody></table>
  
### Customizing Sample Certificates
Follow this [tutorial](https://github.com/Azure-Samples/IoTEdgeAndMlSample/tree/master/CreateCertificates) to create sample certificates for use for the interop solution. It generates certificates with default subject name "turbofanGateway" and 30 days validity.To extend the validity of certificates (or) to change the subject name, make the following modifications and re-build the docker image after that:*   To extend the certificate validity to 365 days, replace "RUN yum -y install openssl git \" with "RUN yum -y install openssl git sed \"*   Add following extra lines after "&& chmod 700 startup.sh"RUN sed -i -e '/days_till_expire/s/30/365/' certGen.sh*   To customize the subject name,add the below line before the "ENTRYPOINT [ "/work/startup.sh" ]"RUN sed -i -e 's/turbofanGateway/sampleedgedevice/' startup.sh
